import scala.annotation.tailrec

object puzzleobj {

  /**
    * Tile is an algebraic data type composed of nine other types.
    * Each represent a tile of the puzzle, including the empty one.
    */

  import scala.collection.mutable.LinkedHashMap
  import scala.collection.mutable.PriorityQueue

  sealed abstract class Tile

  case object Empty extends Tile

  case object One extends Tile

  case object Two extends Tile

  case object Three extends Tile

  case object Four extends Tile

  case object Five extends Tile

  case object Six extends Tile

  case object Seven extends Tile

  case object Eight extends Tile

  /**
    * Puzzle is a list of tiles.
    */
  type Puzzle = List[Tile]

  /**
    * Given a Puzzle, return a list of new puzzles, that is, a list of
    * new possible states. These are generated by "moving" tiles according to
    * the restrictions of the puzzle.
    */
  def unfold(p: Puzzle): List[Puzzle] = {
    /**
      * Swap the position of two elements given their index in the list.
      */
    def swap(p: Puzzle, i1: Int, i2: Int): Puzzle = {
      require(i1 < i2, "i1 should be an index lower than i2")
      val (a, h1 :: b) = p.splitAt(i1)
      val (c, h2 :: d) = b.splitAt(i2 - i1 - 1)
      a ::: (h2 :: c) ::: (h1 :: d)
    }

    var children: List[Puzzle] = Nil
    val i = p.indexWhere(_ == Empty)
    val row = i / 3
    val col = i - (3 * row)

    if (col < 2) children = swap(p, i, i + 1) :: children // right
    if (col > 0) children = swap(p, i - 1, i) :: children // left
    if (row < 2) children = swap(p, i, i + 3) :: children // bottom
    if (row > 0) children = swap(p, i - 3, i) :: children // top

    children
  }

  /**
    * Returns true if the given puzzle represents a solution, false otherwise.
    */
  def isSolution(p: Puzzle): Boolean =
    p.filter(_ != Empty) == List(One, Two, Three, Four, Five, Six, Seven, Eight)

  /**
    * Generates a new random puzzle.
    */
  def newPuzzle: Puzzle = scala.util.Random.shuffle {
    List(Empty, One, Two, Three, Four, Five, Six, Seven, Eight)
  }

  // ==========================================
  // -------------- Your code here ------------
  /**
    * This function converts  a puzzle to a two-dimensional Array
    * We need this function to make the counting of inversions easier
    */
  def convertToArrayMatrix(puzzle: Puzzle): Array[Array[Int]] = {
    val a = Array.ofDim[Int](3, 3)

    def convertTilesToInts(t: Tile): Int = t match {
      case Empty => 0
      case One => 1
      case Two => 2
      case Three => 3
      case Four => 4
      case Five => 5
      case Six => 6
      case Seven => 7
      case Eight => 8
    }

    var b: Puzzle = puzzle
    for (i <- 0 to 2) {
      for (j <- 0 to 2) {
        a(i)(j) = convertTilesToInts(b.head)
        b = b.tail
      }
    }
    a
  }


  /**
    *
    * This piece of code proves whether a puzzle is solveable
    * It counts the number of inversions and checks if it is an even number
    * The code can be found here: https://www.geeksforgeeks.org/check-instance-8-puzzle-solvable/
    */
  def isSolvable(p: Puzzle): Boolean = {
    def getInvCount(arr: Array[Int]): Int = {
      var inv_count = 0
      var i = 0
      while ( {
        i < 9 - 1
      }) {
        var j = i + 1
        while ( {
          j < 9
        }) { // Value 0 is used for empty space
          if (arr(i) != 0 && arr(j) != 0 && arr(i) > arr(j)) {
            inv_count += 1
          }
          {
            j += 1
          }
        }
        {
          i += 1
        }
      }
      inv_count
    }

    val invCount = getInvCount(convertToArrayMatrix(p).flatten)
    invCount % 2 == 0

  }

  /**
    * The base case of the dfs-function is the solution of the puzzle
    * The first recursive-case is when the current node was already visited, we store the visited nodes in path
    * If the current node was visited then we call dfs2 recursively with the adjacent node as the current node
    * The second recursive-case is when the current node was not visited yet, in this case we add it to our path
    * and visit the first child of this node.
   */
  def depthfirstsearch(p: Puzzle): (String, Puzzle, List[Puzzle], Int) = {
    def dfs2(p: Puzzle, path: List[Puzzle], adjacent: List[Puzzle]): (String, Puzzle, List[Puzzle], Int) = {
      val children = unfold(p)

      if (isSolution(p)) ("Solution found:", p, path :+ p, path.length + 1)
      else if (path.contains(p)) dfs2(adjacent.head, path, adjacent.tail)
      else dfs2(children.head, path :+ p, children.tail ++ adjacent)
    }

    if (!isSolvable(p)) ("Not solvable", Nil, Nil, 0)
    else dfs2(p, Nil, Nil)
  }

  /**
    *
    * Our heuristic-function
    */
  def heuristic(p: Puzzle): (String, Puzzle, List[Puzzle], Int) = {
    //This algorithm works similar to the above one, except that it chooses the next child based on the minimum manhattan distance.
    //Furthermore it keeps track of deadends(already seen nodes) and if it reaches one it goes up to the parentnode and saves the deadend in a list.

    //This is my first heuristic function, it calculates the Manhattan distance
    def manhattanDistance(node: Puzzle): Int = {
      val array = convertToArrayMatrix(node)
      val puzzlearray = array.filter(_!=0)
      var cost = 0
      for (i <- 0 to 2) {
        for (j <- 0 to 2) {
          //if (puzzlearray(i)(j) != 0) {
          if(!(i==2 && j==2)){
            val q = (puzzlearray(i)(j) - 1) / 3
            val mod = (puzzlearray(i)(j) - 1) % 3
            cost += math.abs(q - i) + math.abs(mod - j)
          }
        }
      }
      cost
    }
    //this is the second heuristic function, it counts the number of tiles that are out of place
    //however the manhattan distance works better, therefore i am using it.
    //We could parametrize the heuristic function and call heuristic_2 with different heuristic functions.
    def tilesOutOfPlace(p:Puzzle):Int ={
      //first the Empty tile is removed
      val node = p.filter(_ != Empty)
      val goalNode = List(One, Two, Three, Four, Five, Six, Seven, Eight)
      def loop(p:Puzzle,goalNode:Puzzle,acc:Int): Int = {
        if(p.isEmpty) acc
        else if(p.head==goalNode.head) loop(p.tail,goalNode.tail,acc)
        else loop(p.tail,goalNode.tail,acc+1)
    }
    loop(node,goalNode,0)
    }

    /**
      *
      * the base case is as always if the node is solveable
      * In the recursive case it first unfolds the current node and gets its children, then it filters all seen children out
      * If all children are already seen then it chooses the child with the lowest costs. It uses the manhattan distance a the
      * costfunction
      */
    def heuristic_2(p: Puzzle, path: List[Puzzle] = Nil): (String, Puzzle, List[Puzzle], Int) = {
      if (isSolution(p)) {
        ("Solution found:", p, path, path.length)
      }
      else {
        var children = unfold(p)
        //filter nodes from children that already exist in path(already visited)
        children = children.diff(path)

        if (children.isEmpty) {
          heuristic_2(path.reverse.tail.head, path.reverse.tail.reverse)
        }
        else {
          val childWithLowestCost = children.reduceLeft((a, b) => if(manhattanDistance(b) < manhattanDistance(a)) b else a)
          //use this line of code if you want to try the tilesOutOfPlace heuristic-function instead of the manhattandistance
          //val childWithLowestCost = children.reduceLeft((a, b) => if(tilesOutOfPlace(b) < tilesOutOfPlace(a)) b else a)
          heuristic_2(childWithLowestCost, childWithLowestCost :: path)
        }
      }

    }
    if (!isSolvable(p)) ("Not solvable", Nil, Nil, 0)
    else heuristic_2(p)
  }


}
